// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Created extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Created entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Created entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Created", id.toString(), this);
  }

  static load(id: string): Created | null {
    return store.get("Created", id) as Created | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get requestId(): Bytes {
    let value = this.get("requestId");
    return value.toBytes();
  }

  set requestId(value: Bytes) {
    this.set("requestId", Value.fromBytes(value));
  }

  get payee(): Bytes {
    let value = this.get("payee");
    return value.toBytes();
  }

  set payee(value: Bytes) {
    this.set("payee", Value.fromBytes(value));
  }

  get payer(): Bytes {
    let value = this.get("payer");
    return value.toBytes();
  }

  set payer(value: Bytes) {
    this.set("payer", Value.fromBytes(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    return value.toBytes();
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get data(): string {
    let value = this.get("data");
    return value.toString();
  }

  set data(value: string) {
    this.set("data", Value.fromString(value));
  }
}

export class Accepted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Accepted entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Accepted entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Accepted", id.toString(), this);
  }

  static load(id: string): Accepted | null {
    return store.get("Accepted", id) as Accepted | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get requestId(): Bytes {
    let value = this.get("requestId");
    return value.toBytes();
  }

  set requestId(value: Bytes) {
    this.set("requestId", Value.fromBytes(value));
  }
}

export class Canceled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Canceled entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Canceled entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Canceled", id.toString(), this);
  }

  static load(id: string): Canceled | null {
    return store.get("Canceled", id) as Canceled | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get requestId(): Bytes {
    let value = this.get("requestId");
    return value.toBytes();
  }

  set requestId(value: Bytes) {
    this.set("requestId", Value.fromBytes(value));
  }
}

export class NewSubPayee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save NewSubPayee entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save NewSubPayee entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("NewSubPayee", id.toString(), this);
  }

  static load(id: string): NewSubPayee | null {
    return store.get("NewSubPayee", id) as NewSubPayee | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get requestId(): Bytes {
    let value = this.get("requestId");
    return value.toBytes();
  }

  set requestId(value: Bytes) {
    this.set("requestId", Value.fromBytes(value));
  }

  get payee(): Bytes {
    let value = this.get("payee");
    return value.toBytes();
  }

  set payee(value: Bytes) {
    this.set("payee", Value.fromBytes(value));
  }
}

export class UpdateExpectedAmount extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UpdateExpectedAmount entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UpdateExpectedAmount entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UpdateExpectedAmount", id.toString(), this);
  }

  static load(id: string): UpdateExpectedAmount | null {
    return store.get("UpdateExpectedAmount", id) as UpdateExpectedAmount | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get requestId(): Bytes {
    let value = this.get("requestId");
    return value.toBytes();
  }

  set requestId(value: Bytes) {
    this.set("requestId", Value.fromBytes(value));
  }

  get payeeIndex(): i32 {
    let value = this.get("payeeIndex");
    return value.toI32();
  }

  set payeeIndex(value: i32) {
    this.set("payeeIndex", Value.fromI32(value));
  }

  get deltaAmount(): BigInt {
    let value = this.get("deltaAmount");
    return value.toBigInt();
  }

  set deltaAmount(value: BigInt) {
    this.set("deltaAmount", Value.fromBigInt(value));
  }
}

export class UpdateBalance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save UpdateBalance entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UpdateBalance entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UpdateBalance", id.toString(), this);
  }

  static load(id: string): UpdateBalance | null {
    return store.get("UpdateBalance", id) as UpdateBalance | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get requestId(): Bytes {
    let value = this.get("requestId");
    return value.toBytes();
  }

  set requestId(value: Bytes) {
    this.set("requestId", Value.fromBytes(value));
  }

  get payeeIndex(): i32 {
    let value = this.get("payeeIndex");
    return value.toI32();
  }

  set payeeIndex(value: i32) {
    this.set("payeeIndex", Value.fromI32(value));
  }

  get deltaAmount(): BigInt {
    let value = this.get("deltaAmount");
    return value.toBigInt();
  }

  set deltaAmount(value: BigInt) {
    this.set("deltaAmount", Value.fromBigInt(value));
  }
}

export class NewTrustedContract extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save NewTrustedContract entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save NewTrustedContract entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("NewTrustedContract", id.toString(), this);
  }

  static load(id: string): NewTrustedContract | null {
    return store.get("NewTrustedContract", id) as NewTrustedContract | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get newContract(): Bytes {
    let value = this.get("newContract");
    return value.toBytes();
  }

  set newContract(value: Bytes) {
    this.set("newContract", Value.fromBytes(value));
  }
}

export class RemoveTrustedContract extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RemoveTrustedContract entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RemoveTrustedContract entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RemoveTrustedContract", id.toString(), this);
  }

  static load(id: string): RemoveTrustedContract | null {
    return store.get(
      "RemoveTrustedContract",
      id
    ) as RemoveTrustedContract | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldContract(): Bytes {
    let value = this.get("oldContract");
    return value.toBytes();
  }

  set oldContract(value: Bytes) {
    this.set("oldContract", Value.fromBytes(value));
  }
}

export class Pause extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Pause entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Pause entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Pause", id.toString(), this);
  }

  static load(id: string): Pause | null {
    return store.get("Pause", id) as Pause | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class Unpause extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Unpause entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unpause entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Unpause", id.toString(), this);
  }

  static load(id: string): Unpause | null {
    return store.get("Unpause", id) as Unpause | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save OwnershipTransferred entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save OwnershipTransferred entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("OwnershipTransferred", id.toString(), this);
  }

  static load(id: string): OwnershipTransferred | null {
    return store.get("OwnershipTransferred", id) as OwnershipTransferred | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}
